{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap b6f1614aef28f1828771","webpack:///external \"rxjs\"","webpack:///./src/Store/Store.js","webpack:///./src/Store/index.js","webpack:///./src/Engine/Engine.js","webpack:///./src/Engine/index.js","webpack:///./src/constants.js","webpack:///./src/util.js","webpack:///./src/EngineMerger/EngineMerger.js","webpack:///./src/EngineMerger/defaultReducers.js","webpack:///./src/EngineMerger/index.js","webpack:///./src/Change/Change.js","webpack:///./src/Change/index.js","webpack:///./src/index.js","webpack:///./src/bottle.js","webpack:///external \"bottlejs\""],"names":["bottle","isPromise","constructor","props","stop","_idFromProps","Store","id","lGet","Number","_parseProps","initializer","firstState","debug","noChangeBeforeInit","_initStateStream","distinctUntilChanged","_initErrorStream","_initDebugStream","params","data","change","JSON","type","store_state","store_status","_initStream","status","_resolveChangePromise","ext","call","error","_resolveChangeFunction","console","_delayedChange","_changeError","_initChangeStream","message","onChange","Promise","init","changeRecord","_setState","_setStatus","subscribe","initialize","onInit","sub","_debugMessage","target","store","Change","actions","Object","_initActionStream","onAction","done","actionStatus","fail","_getTID","perform","tid","mutator","engine","Symbol","out","first","result","err","fn","promise","delta","subject","state","killSwitch","from","errorMessage","delayTime","delay","race","STATUS_MAP","_listenToEngineStreams","e","_updateState","obsList","stateWatcher","o","combineLatest","finished","responded","Array","obj","baseActions","actionsMemo","action","STORE_STATE_UNSET_VALUE","states","newState","defaultReducers","engineMerger","explodePromise","extend","callbacks","functionCombine","combinedParams","toJSON","name","asPromise","after","propper","defaultValue","required","onInvalid","tests","isGood","n","Bottle","constants","util","container","Engine","EngineMerger","update","mergeIntoState","STORE_STATUS_NEW","STORE_STATUS_INITIALIZED","STORE_STATUS_INITIALIZING","STORE_STATUS_INITIALIZATION_ERROR","ACTION_ERROR","ACTION_START","ACTION_NOOP","ACTION_COMPLETE","NOT_SET"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"freactal3\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"freactal3\"] = factory();\n\telse\n\t\troot[\"freactal3\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b6f1614aef28f1828771","module.exports = require(\"rxjs\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"rxjs\"\n// module id = 0\n// module chunks = 0","/* eslint-disable no-unreachable,no-empty */\nimport { combineLatest, BehaviorSubject, from } from 'rxjs';\nimport { map, distinctUntilChanged, pairwise, filter } from 'rxjs/operators';\nimport lGet from 'lodash.get';\nimport lClone from 'lodash.clonedeep';\n\nexport default (bottle) => {\n  bottle.factory(\n    'Store',\n    ({\n      STORE_STATE_UNSET_VALUE,\n      STORE_STATUS_NEW,\n      STORE_STATUS_INITIALIZING,\n      STORE_STATUS_INITIALIZATION_ERROR,\n      STORE_STATUS_INITIALIZED,\n      STORE_STATUS_STOPPED,\n      NOT_SET,\n      Change,\n      p, call, isPromise,\n    }) => {\n      class Store {\n        constructor(props = null) {\n          this._idFromProps(props);\n          this._parseProps(props);\n\n          this._initChangeStream();\n          this._initStateStream();\n          this._initErrorStream();\n          this._initStream();\n\n\n          if (this._debug) {\n            this._initDebugStream();\n          }\n\n          this._setStatus(STORE_STATUS_NEW);\n        }\n\n        stop() {\n          this._setStatus(STORE_STATUS_STOPPED);\n          this._changeStream.complete();\n          this._stateStream.complete();\n          this._stream.complete();\n          this._errorStream.complete();\n          if (this._debugStream) this._debugStream.complete();\n        }\n\n        _idFromProps(props) {\n          if (!Store._nextID) Store._nextID = 0;\n          if (props) {\n            const id = lGet(props, 'id');\n            if ((id) && (typeof id === 'string')) {\n              this.id = id;\n              return;\n            }\n            if ((id) && Number.isInteger(id) && (id >= Store._nextID)) {\n              this.id = id;\n              Store._nextID = id + 1;\n              return;\n            }\n          }\n          Store._nextID += 1;\n          this.id = Store._nextID;\n        }\n\n        /**\n         * props can be:\n         *\n         * 1: a function, in which case its the initializer.\n         * 2: an object with state or initializer as props, in which case its a parameter group\n         * 3. an object without state or initializer in which case its the firstState\n         *\n         * @param props\n         * @private\n         */\n\n        _parseProps(props) {\n          this._idFromProps(props);\n          this._firstState = STORE_STATE_UNSET_VALUE;\n          if (!props) return;\n          if (typeof props === 'function') {\n            props = { initializer: props };\n          }\n          let debug = false;\n          let initializer = null;\n          let firstState = STORE_STATE_UNSET_VALUE;\n          let noChangeBeforeInit = true;\n\n          if (typeof props === 'object') {\n            if ('state' in props || 'initializer' in props) {\n              initializer = lGet(props, 'initializer', initializer);\n              firstState = lGet(props, 'state', firstState);\n              debug = lGet(props, 'debug', debug);\n              noChangeBeforeInit = lGet(props, 'noChangeBeforeInit', noChangeBeforeInit);\n            } else {\n              firstState = props;\n            }\n\n            this._firstState = firstState;\n            this._initializer = initializer;\n          } else {\n            this._firstState = props;\n          }\n\n          this._noChangeBeforeInit = noChangeBeforeInit;\n          this._debug = debug;\n        }\n\n        _initStateStream() {\n          this._stateStream = new BehaviorSubject(this._firstState)\n            .pipe(distinctUntilChanged());\n          this._stateStream.subscribe((next) => {\n            this._state = next;\n          });\n        }\n\n        _initErrorStream() {\n          this._errorStream = new BehaviorSubject()\n            .pipe(distinctUntilChanged());\n        }\n\n        _initDebugStream() {\n          this._debugStream = new BehaviorSubject()\n            .pipe(map((data) => {\n              let params = data.params;\n              let change = null;\n              if (params instanceof Change) {\n                switch (params.type) {\n                  case 'value':\n                    if (typeof params.change === 'symbol') {\n                      change = params.change.toString();\n                    } else {\n                      try {\n                        change = JSON.stringify(params.change);\n                      } catch (err) {\n                        change = params.change;\n                      }\n                    }\n                    break;\n\n                  default:\n                    change = `change -- ${params.type}`;\n                }\n                return Object.assign({}, data, {\n                  store_state: this.state, store_status: this.status, change,\n                });\n              }\n              // console.log('params not change:> ', params);\n              if (typeof params === 'object') {\n                try {\n                  params = JSON.stringify(params);\n                } catch (err) {}\n              }\n              return Object.assign({}, data, {\n                store_state: this.state, store_status: this.status, params,\n              });\n            }));\n          /*          this._errorStream.subscribe((error) => {\n            this._debugStream.next({\n              source: '----(errorStream)',\n              message: 'error',\n              params: error,\n            });\n          });\n\n          this._changeStream.subscribe((params) => {\n            this._debugStream.next({\n              source: '-----(changeStream)',\n              message: 'params',\n              params,\n            });\n          });\n\n          this._stateStream.subscribe((state) => {\n            this._debugStream.next({\n              source: '----(stateStream)',\n              message: 'state',\n              params: state,\n            });\n          }); */\n        }\n\n        _initStream() {\n          this._stream = combineLatest(this._stateStream, this._statusStream)\n            .pipe(map(([streamedState, streamedStatus]) => ({\n              state: streamedState,\n              status: streamedStatus,\n            })), distinctUntilChanged());\n        }\n\n        _resolveChangePromise(params) {\n          const {\n            change,\n            fail = NOT_SET,\n          } = params;\n\n          this._debugMessage('change stream', 'is promise', params);\n          change\n            .then((newChange) => {\n              const ext = params.extend({ change: newChange });\n              this._debugMessage('change stream', '============= resolved', { params, newChange });\n              this.change(ext);\n            })\n            .catch((error) => {\n              this._debugMessage('change stream', '============= rejected', { params, error });\n              call(fail, error);\n              this._errorStream.next({\n                ...params,\n                error,\n              });\n            });\n        }\n\n        _resolveChangeFunction(params) {\n          this._debugMessage('_resolveChangeFunction', 'chaining', params);\n          console.log('resolving function', params);\n          this.change(params.extend({ change: params.change(this.state) }));\n        }\n\n        _delayedChange(params) {\n          // until status is updated changes are buffered\n          this._debugMessage('change stream', 'delaying execution until initializing is done', params);\n          this.onInit(params);\n        }\n\n        _changeError(error, params) {\n          const {\n            fail = NOT_SET,\n          } = params;\n\n          this._debugMessage('change stream', 'is error', { ...params, error });\n\n          call(fail, error, params);\n          this._errorStream.next({\n            ...params,\n            error,\n          });\n        }\n\n        _initChangeStream() {\n          this._changeStream = new BehaviorSubject(NOT_SET);\n          this._changeStream.subscribe(params => this.onChange(params), (error) => {\n            this._errorStream.next({\n              message: 'change stream error',\n              error,\n            });\n          });\n        }\n\n        onChange(params = NOT_SET) {\n          if (params === NOT_SET) {\n            return;\n          }\n\n          if (typeof params !== 'object') {\n            this.onChange({ change: params });\n            return;\n          }\n\n          const {\n            change = NOT_SET,\n            done,\n            status,\n          } = params;\n\n          if (this.isInitializeError) {\n            this._changeError(this.initializationError, params);\n            return;\n          }\n\n          if (!params) {\n            this._changeError(new Error('no change specified'), params);\n            return;\n          }\n\n          if (this._noChangeBeforeInit && !status) {\n            switch (this.status) {\n              case STORE_STATUS_INITIALIZING:\n                this._debugMessage('onChange', 'change before init -- suppressing', params);\n                return;\n                break;\n\n              case STORE_STATUS_NEW:\n                this._debugMessage('onChange', 'change while new -- suppressing', params);\n                return;\n                break;\n\n              default:\n              // continue;\n            }\n          }\n\n          if (isPromise(change)) {\n            this._resolveChangePromise(params);\n            return;\n          }\n\n          if (typeof change === 'function') {\n            this._resolveChangeFunction(params);\n            return;\n          }\n\n          if (!this.isInitialized) {\n            if (!status) {\n              this._delayedChange(params);\n              return;\n            }\n          }\n\n          if (status) {\n            this._setStatus(status);\n          }\n          this._setState(change);\n\n          call(done, this.state);\n        }\n\n        change(params = NOT_SET) {\n          if (params === NOT_SET) return Promise.resolve(NOT_SET);\n          let init = params;\n          if (typeof params === 'object' && (!params.change)) {\n            init = { change: params };\n          }\n          const changeRecord = (params instanceof Change) ? params : new Change(init);\n          const [change, promise] = changeRecord.asPromise();\n          this._changeStream.next(change);\n          return promise;\n        }\n\n        get state() {\n          return this._state;\n        }\n\n        _setState(value = NOT_SET) {\n          if (value !== NOT_SET) {\n            this._stateStream.next(value);\n          }\n        }\n\n        get status() {\n          return this._status;\n        }\n\n        _setStatus(status) {\n          if ([\n            STORE_STATUS_NEW,\n            STORE_STATUS_INITIALIZING,\n            STORE_STATUS_INITIALIZED,\n            STORE_STATUS_INITIALIZATION_ERROR,\n          ].includes(status)) {\n            this._status = status;\n          }\n        }\n\n        subscribe(...args) {\n          return this._stateStream.subscribe(...args);\n        }\n\n        get isInitializing() {\n          return this.status === STORE_STATUS_INITIALIZING;\n        }\n\n        get isNotUninitialized() {\n          return this.isInitialized || this.isInitializeError;\n        }\n\n        get isInitialized() {\n          return (this.status === STORE_STATUS_INITIALIZED);\n        }\n\n        get isInitializeError() {\n          return (this.status === STORE_STATUS_INITIALIZATION_ERROR);\n        }\n\n        initialize() {\n          if (this._initPromise) return this._initPromise;\n          this._debugMessage('initialize', '==========initializing');\n          this._setState(this._firstState);\n          if (this._initializer) {\n            this.change({\n              change: this._firstState, status: STORE_STATUS_INITIALIZING,\n            });\n            this._initPromise = this.change({\n              change: this._initializer, status: STORE_STATUS_INITIALIZED,\n            });\n          } else {\n            this._initPromise = this.change({\n              change: this._firstState, status: STORE_STATUS_INITIALIZED,\n            });\n          }\n          return this._initPromise;\n        }\n        /**\n         * this method delays an action until the store has been initialized\n         * (or is in init error state).\n         *\n         * @param params {change} or legit arguments to the new change constructor.\n         *\n         * @returns {Promise<never>}\n         */\n        onInit(params) {\n          const {\n            fail,\n          } = params;\n\n          if (this.isInitialized) {\n            return this.change(params);\n          }\n\n          if (this.isInitializeError) {\n            call(fail, this.initializationError);\n            return Promise.reject(this.initializationError);\n          }\n\n          let changeRecord;\n          if (!(params instanceof Change)) {\n            changeRecord = new Change(params);\n          } else {\n            changeRecord = params;\n          }\n\n          const [change, promise] = changeRecord.asPromise();\n\n          const sub = this._statusStream.subscribe(\n            (status) => {\n              switch (status) {\n                case STORE_STATUS_INITIALIZED:\n                  sub.unsubscribe();\n                  this.change(change);\n                  break;\n\n                case STORE_STATUS_INITIALIZATION_ERROR:\n                  sub.unsubscribe();\n                  call(change.fail, this.initializationError, this);\n                  break;\n\n                default:\n              }\n            },\n            (error) => {\n              call(change.fail, error, this);\n            },\n          );\n\n          return promise;\n        }\n\n        _debugMessage(source, message, params = NOT_SET) {\n          if (this._debug) {\n            this._debugStream.next({\n              target: this.id,\n              source,\n              message,\n              params,\n            });\n          }\n        }\n      }\n\n      return Store;\n    },\n  );\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/Store/Store.js","import store from './Store';\n\nexport default (bottle) => {\n  store(bottle);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/Store/index.js","import { combineLatest, BehaviorSubject, from } from 'rxjs';\nimport { map, distinctUntilChanged, pairwise, filter } from 'rxjs/operators';\nimport lGet from 'lodash.get';\nimport lClone from 'lodash.clonedeep';\n\nexport default (bottle) => {\n  bottle.factory(\n    'Engine',\n    ({\n      STORE_STATE_UNSET_VALUE,\n      STORE_STATUS_NEW,\n      STORE_STATUS_INITIALIZING,\n      STORE_STATUS_INITIALIZATION_ERROR,\n      STORE_STATUS_INITIALIZED,\n\n      ACTION_START,\n      ACTION_COMPLETE,\n      ACTION_ERROR,\n\n      NOT_SET,\n      p, call, isPromise, explodePromise,\n      Store, Change,\n    }) => {\n      class Engine extends Store {\n        constructor(params, actions) {\n          super(params);\n          this._initActionStream();\n          this.mutators = actions || lGet(params, actions);\n          this.initialize();\n        }\n\n        get actions() {\n          if (!this._actions) {\n            const actions = {};\n\n            Object.keys(this.mutators)\n              .forEach((method) => {\n                actions[method] = (...params) => this.perform({\n                  method,\n                  actions,\n                  params,\n                });\n              });\n\n            this._actions = actions;\n          }\n          return this._actions;\n        }\n\n        _initActionStream() {\n          this.actionStream = new BehaviorSubject();\n          this.actionStream.subscribe(params => this.onAction(params), (error) => {\n            this._errorStream.next({ message: 'action error', error });\n          });\n        }\n\n        onAction(changeRecord) {\n          if (!changeRecord) return;\n          this._debugMessage('onAction', '(init)', changeRecord);\n          const {\n            actionStatus = NOT_SET,\n            change,\n          } = changeRecord;\n\n          if (!change) {\n            if (actionStatus !== ACTION_ERROR) {\n              this.actionStream.next(changeRecord.extend({\n                actionStatus: ACTION_ERROR,\n                error: new Error(`cannot find method ${lGet(changeRecord, 'method', '???')}`),\n              }));\n              return;\n            }\n          }\n\n          if (actionStatus === ACTION_START) {\n            this._debugMessage('onAction', 'chaining action call ', changeRecord);\n            this.change(changeRecord.extend({\n              done: () => {\n                this.actionStream.next(changeRecord.extend({\n                  actionStatus: ACTION_COMPLETE,\n                }));\n              },\n              fail: (error) => {\n                this.actionStream.next(changeRecord.extend({\n                  error, actionStatus: ACTION_ERROR,\n                }));\n              },\n              actionStatus: NOT_SET,\n            }));\n          } else if (actionStatus === ACTION_ERROR) {\n            call(lGet(changeRecord, 'fail'));\n          } else {\n            this._debugMessage('onAction', 'NOT chaining action call ', changeRecord);\n          }\n        }\n\n        _getTID() {\n          if (!this._tid) {\n            this._tid = 0;\n          }\n          this._tid += 1;\n          return this._tid;\n        }\n\n        perform(params) {\n          const changeRecord = new Change({\n            ...params,\n            tid: this._getTID(),\n            actionStatus: ACTION_START,\n          });\n\n          let {\n            // eslint-disable-next-line prefer-const\n            method, actions = this.actions, params: methodParams,\n          } = changeRecord;\n          const mutator = lGet(this.mutators, method);\n\n\n          if (mutator && typeof mutator === 'function') {\n            changeRecord.change = mutator(actions, ...methodParams);\n          }\n          this._debugMessage('perform', 'mutator:', changeRecord);\n          const { promise, change: actionChange } = changeRecord.asPromise();\n\n          this.actionStream.next(actionChange);\n\n          return promise;\n        }\n      }\n\n      return Engine;\n    },\n  );\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/Engine/Engine.js","import engine from './Engine';\n\nexport default (bottle) => {\n  engine(bottle);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/Engine/index.js","\n\nexport default (bottle) => {\n  bottle.constant('STORE_STATE_UNSET_VALUE', Symbol('STORE_STATE_UNSET_VALUE'));\n  bottle.constant('STORE_STATUS_NEW', Symbol('STORE_STATUS_NEW'));\n  bottle.constant('STORE_STATUS_INITIALIZED', Symbol('STORE_STATUS_INITIALIZED'));\n  bottle.constant('STORE_STATUS_STOPPED', Symbol('STORE_STATUS_STOPPED'));\n  bottle.constant('STORE_STATUS_INITIALIZING', Symbol('STORE_STATUS_INITIALIZING'));\n  bottle.constant('STORE_STATUS_INITIALIZATION_ERROR', Symbol('STORE_STATUS_INITIALIZATION_ERROR'));\n  bottle.constant('ACTION_ERROR', Symbol('ACTION_ERROR'));\n  bottle.constant('ACTION_START', Symbol('ACTION_START'));\n  bottle.constant('ACTION_NOOP', Symbol('ACTION_NOOP'));\n  bottle.constant('ACTION_COMPLETE', Symbol('ACTION_COMPLETE'));\n  bottle.constant('NOT_SET', Symbol('NOT_SET'));\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/constants.js","import { from, race } from 'rxjs';\nimport { delay } from 'rxjs/operators';\n\nexport default (bottle) => {\n  /**\n   * decomposes a promise into result and error;\n   * returns these in an array which also has properties of result and error,\n   * so\n   *\n   * const [result, error] = p(promiseFn())\n   *\n   * is valid as is\n   *\n   * const {result, error} = p(promiseFn());\n   *\n   * accepts a promise, or a function that is called with the remaining arguments.\n   */\n  bottle.factory('p', () => async (first, ...args) => {\n    let error = null;\n    let result;\n    try {\n      if (typeof first === 'function') {\n        result = await first(...args);\n      } else {\n        result = await (first);\n      }\n    } catch (err) {\n      error = err;\n    }\n    const out = [result, error];\n    out.result = result;\n    out.error = error;\n    return out;\n  });\n\n  bottle.factory('call', () => (fn, ...args) => {\n    if (fn && typeof fn === 'function') {\n      return fn(args);\n    }\n    return null;\n  });\n\n  bottle.factory('explodePromise', ({ NOT_SET, isPromise }) => (promise) => {\n    let done = NOT_SET;\n    let fail = NOT_SET;\n\n    if (isPromise(promise)) {\n      done = (...args) => [...args];\n      fail = (...args) => [...args];\n      promise.then(done).catch(fail);\n    } else promise = new Promise((d, f) => { done = d; fail = f; });\n\n    return Object.assign([promise, done, fail], { done, fail, promise });\n  });\n\n  bottle.factory('update', () => function (delta) {\n    return (actions, ...args) => (state) => {\n      const change = delta(actions, ...args)(state);\n      return Object.assign({}, state, change);\n    };\n  });\n\n  bottle.factory('obj', () => (key, value) => {\n    const out = {};\n    out[key] = value;\n    return out;\n  });\n\n  bottle.constant('NOOP', a => a);\n\n  bottle.factory('isPromise', () => (subject) => {\n    if (!subject) return false;\n    if (subject instanceof Promise) return true;\n    return Promise.resolve(subject) === subject;\n  });\n\n  bottle.factory('functionCombine', ({ call }) => (f1, f2) => async (...args) => {\n    await call(f1, ...args);\n    return call(f2, ...args);\n  });\n\n  bottle.factory('mergeIntoState', () => change => state => Object.assign({}, state, change));\n\n  bottle.factory('timeLimitObservable', () => (observable, delayTime = 1000, errorMessage) => {\n    const killSwitch = from([false, new Error(errorMessage || `took over ${delayTime / 1000} secs`)])\n      .pipe(delay(delayTime));\n\n    return race(observable, killSwitch);\n  });\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/util.js","/* eslint-disable no-undef,prefer-promise-reject-errors */\nimport { combineLatest, BehaviorSubject, Observable, from, fork } from 'rxjs';\nimport { map, distinctUntilChanged, pairwise, filter } from 'rxjs/operators';\nimport lGet from 'lodash.get';\nimport lClone from 'lodash.clonedeep';\nimport lGroupBy from 'lodash.groupby';\n\nexport default (bottle) => {\n  bottle.factory(\n    'EngineMerger',\n    ({\n      STORE_STATUS_NEW,\n      STORE_STATUS_INITIALIZING,\n      STORE_STATUS_INITIALIZATION_ERROR,\n      STORE_STATUS_INITIALIZED,\n      STORE_STATE_UNSET_VALUE,\n\n      defaultActionReducer,\n      defaultStateReducer,\n      ACTION_START,\n      ACTION_COMPLETE,\n      ACTION_ERROR,\n\n      NOT_SET,\n      p, call, isPromise, explodePromise, obj, timeLimitObservable,\n      Store,\n    }) => {\n      const STATUS_MAP = new Map();\n      STATUS_MAP.set(STORE_STATUS_NEW, 'new');\n      STATUS_MAP.set(STORE_STATUS_INITIALIZATION_ERROR, 'error');\n      STATUS_MAP.set(STORE_STATUS_INITIALIZED, 'initialized');\n      STATUS_MAP.set(STORE_STATUS_INITIALIZING, 'initializing');\n      STATUS_MAP.set(NOT_SET, 'other');\n\n      class EngineMerger extends Store {\n        constructor(params) {\n          super(params);\n          this._initActionStream();\n\n          this.initialize();\n        }\n\n        _parseProps(params) {\n          this._idFromProps(params);\n\n          this.engines = lGet(params, 'engines', []);\n          this._stateReducer = lGet(params, 'stateReducer', defaultStateReducer);\n          this._actionsReducer = lGet(params, 'actionReducer', defaultActionReducer);\n          this._firstState = lGet(params, 'state', STORE_STATE_UNSET_VALUE);\n          this._maxInitWait = lGet(params, 'maxInitWait', 10 * 1000);\n          this._listenToEngineStreams();\n          this._debug = lGet(params, 'debug', params);\n        }\n\n        get actions() {\n          if (!this._actions) {\n            this._actions = this._actionsReducer(this.engines);\n          }\n          return this._actions;\n        }\n\n        _listenToEngineStreams() {\n          this.enginesArray.forEach(e => e.subscribe(() => {\n            this._updateState();\n          }, (err) => {\n            console.log('error on ', e, err);\n          }, () => {\n            console.log('engine shut down');\n          }));\n        }\n\n        _updateState() {\n          if (this.status === STORE_STATUS_INITIALIZED) {\n            this._stateStream.next(this._stateReducer(this.states));\n          }\n        }\n\n        _initActionStream() {\n          this.actionStream = new BehaviorSubject();\n          this.actionStream.subscribe(params => this.onAction(params), (error) => {\n            this._errorStream.next({ message: 'action error', error });\n          });\n        }\n\n        initialize() {\n          this._debugMessage('initialize', '========== initializing', {});\n          if (this._initPromise) return this._initPromise;\n\n          this.change({ change: this._firstState || STORE_STATE_UNSET_VALUE, status: STORE_STATUS_INITIALIZING });\n\n          this._initPromise = this.change({\n            status: STORE_STATUS_INITIALIZED,\n            change: this._waitEngineInit(),\n          });\n\n          return this._initPromise;\n        }\n\n        async _waitEngineInit() {\n          let responded = false;\n          this._debugMessage('_waitEngineInit', 'initializing', this.engines);\n          const obsList = this.enginesArray.map((engine) => {\n            if (engine.isInitialized) {\n              return null;\n            }\n            this._debugMessage('_waitEngineInit', 'watching engine', engine.id);\n            const stateWatcher = new BehaviorSubject(engine.status);\n            engine.subscribe(() => {\n              stateWatcher.next(engine.status);\n            }, (error) => {\n              stateWatcher.error(error);\n            }, () => {\n            });\n\n            return stateWatcher;\n          }).filter(o => o !== null);\n\n          if (obsList.length < 1) {\n            console.log('all done, returning ', this._stateReducer(this.states));\n            return this._stateReducer(this.states);\n          }\n\n          return new Promise((done, fail) => {\n            combineLatest(obsList).subscribe((result) => {\n              console.log('result: ', result);\n              if (responded) return;\n              let finished = true;\n              console.log('');\n              result.forEach((value) => {\n                if (responded) return;\n                switch (value) {\n                  case STORE_STATUS_INITIALIZED:\n                    // do nothing;\n                    break;\n\n                  case STORE_STATUS_INITIALIZING:\n                    finished = false;\n                    break;\n\n                  case STORE_STATUS_INITIALIZATION_ERROR:\n                    finished = false;\n                    responded = true;\n                    fail();\n                    break;\n\n                  default:\n                    console.log('other value:', value);\n                    finished = false;\n                    responded = true;\n                    fail();\n                    // some error\n                }\n              });\n              if (finished) {\n                console.log('finished initializing engine', this._stateReducer(this.states));\n                responded = true;\n                done(this._stateReducer(this.states));\n              } else {\n                console.log('not done with engine');\n              }\n            }, (error) => {\n              if (responded) return;\n              responded = true;\n              fail({\n                status: STORE_STATUS_INITIALIZATION_ERROR,\n                change: this.state,\n                error,\n              });\n            }, () => {\n              if (responded) return;\n              responded = true;\n              this._debugMessage('_waitEngineInit', 'result complete: ', result);\n              done(this._stateReducer(this.states));\n            });\n          });\n        }\n\n        get engineKeys() {\n          return Object.keys(this.engines).sort();\n        }\n\n        get states() {\n          if (Array.isArray(this.engines)) return this.engines.map(e => e.state);\n          if (typeof this.engines === 'object') {\n            // eslint-disable-next-line arrow-body-style\n            return this.engineKeys.reduce((memo, key) => {\n              return ({ ...memo, ...obj(key, this.engines[key].state) });\n            }, {});\n          }\n          console.log('this engines is not right:', this.engines);\n          return STORE_STATE_UNSET_VALUE;\n        }\n\n        get enginesArray() {\n          if (Array.isArray(this.engines)) {\n            return this.engines.slice(0);\n          }\n          if (typeof this.engines === 'object') {\n            return this.engineKeys.reduce((memo, key) => [...memo, this.engines[key]], []);\n          }\n          return [];\n        }\n\n        get statesArray() {\n          return this.enginesArray.map(e => e.state);\n        }\n\n        onAction(params) {\n          if (!params) return;\n          this._debugMessage('onAction', '(init)', params);\n          const {\n            actionStatus = NOT_SET,\n            change,\n          } = params;\n\n          if (!change) {\n            if (actionStatus !== ACTION_ERROR) {\n              this.actionStream.next(Object.extend({}, params, {\n                actionStatus: ACTION_ERROR,\n                error: new Error(`cannot find method ${lGet(params, 'method', '???')}`),\n              }));\n              return;\n            }\n          }\n\n          if (actionStatus === ACTION_START) {\n            this._debugMessage('onAction', 'chaining action call ', params);\n            this.change(this._extendParams(params, {\n              done: () => {\n                this.actionStream.next(Object.assign({}, params, {\n                  actionStatus: ACTION_COMPLETE,\n                }));\n              },\n              fail: (error) => {\n                this.actionStream.next(Object.assign({}, params, {\n                  error, actionStatus: ACTION_ERROR,\n                }));\n              },\n              actionStatus: NOT_SET,\n            }));\n          } else if (actionStatus === ACTION_ERROR) {\n            call(lGet(params, 'fail'));\n          } else {\n            this._debugMessage('onAction', 'NOT chaining action call ', params);\n          }\n        }\n\n        _getTID() {\n          if (!this._tid) {\n            this._tid = 0;\n          }\n          this._tid += 1;\n          return this._tid;\n        }\n\n        perform(params) {\n          const [promise, done, fail] = explodePromise();\n          let {\n            // eslint-disable-next-line prefer-const\n            method, change, actions = this.actions, params: methodParams,\n          } = params;\n          const mutator = lGet(this.mutators, method, NOT_SET);\n\n          if (mutator) change = mutator(actions, ...methodParams);\n\n          const tid = this._getTID();\n\n          this._debugMessage('perform', 'mutator:', {\n            mutator,\n            params,\n            change,\n            tid,\n          });\n\n          this.actionStream.next(this._extendParams(params, {\n            done,\n            fail,\n            tid,\n            change,\n            actionStatus: ACTION_START,\n          }));\n          return promise;\n        }\n      }\n\n\n      return EngineMerger;\n    },\n  );\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/EngineMerger/EngineMerger.js","\nexport default (bottle) => {\n  bottle.factory('defaultActionReducer', () => function (engines) {\n    if (Array.isArray(engines)) {\n      return engines.reduce((actionsMemo, engine) => {\n        // with an array, actions will shadow other actions of the\n        // same name preferring right most engines. However all original\n        // actions will be available in the baseActions array.\n        let baseActions = actionsMemo.baseActions;\n        if (baseActions) {\n          baseActions = [...baseActions, engine.actions];\n        } else {\n          baseActions = [engine.actions];\n        }\n        const actions = { ...actionsMemo, baseActions };\n        Object.keys(engine.mutators).forEach((method) => {\n          actions[method] = (...params) => engine.perform({\n            actions, method, params,\n          });\n        });\n        return actions;\n      }, {});\n    } else if (typeof engines === 'object') {\n      const actions = { baseActions: {} };\n\n      Object.keys(engines).forEach((engineName) => {\n        const engine = engines[engineName];\n        actions[engineName] = {};\n        Object.keys(engine.mutators).forEach((method) => {\n          const action = (...params) => engine.perform({\n            actions, method, params,\n          });\n          actions[engineName][method] = action;\n          actions[method] = action;\n          actions.baseActions[engineName] = engine.actions;\n        });\n      });\n      return actions;\n    }\n    throw new Error('bad engines for defaultActionReducer');\n  });\n\n  bottle.factory('defaultStateReducer', ({\n    STORE_STATE_UNSET_VALUE,\n  }) => (states) => {\n    if (states === STORE_STATE_UNSET_VALUE) return states;\n    if (Array.isArray(states)) {\n      return states.reduce((newState, state) => ({ ...newState, ...state }), {});\n    } else if (typeof states === 'object') {\n      const newState = {};\n      Object.keys(states).forEach((engineName) => {\n        Object.keys(states[engineName]).forEach((fieldName) => {\n          newState[fieldName] = states[engineName][fieldName];\n        });\n        Object.assign(newState, states);\n      });\n      return newState;\n    }\n    console.log('bad state:', states);\n    throw new Error('bad state passed to defaultStateReducer');\n  });\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/EngineMerger/defaultReducers.js","import engineMerger from './EngineMerger';\nimport defaultReducers from './defaultReducers';\n\nexport default (bottle) => {\n  defaultReducers(bottle);\n  engineMerger(bottle);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/EngineMerger/index.js","import lGet from 'lodash.get';\nimport propper from '@wonderlandlabs/propper';\n\nexport default (bottle) => {\n  bottle.factory('Change', ({\n    ACTION_ERROR, ACTION_START, ACTION_NOOP, ACTION_COMPLETE, NOOP, NOT_SET,\n    STORE_STATE_UNSET_VALUE,\n    STORE_STATUS_NEW,\n    STORE_STATUS_INITIALIZING,\n    STORE_STATUS_INITIALIZATION_ERROR,\n    STORE_STATUS_INITIALIZED,\n    isPromise, functionCombine, explodePromise,\n  }) => {\n    class Change {\n      constructor(params = {}) {\n        Object.assign(this, params);\n\n        if (!this.id) {\n          ++Change.nextID;\n          this.id = Change.nextID;\n        }\n      }\n\n      get type() {\n        if (isPromise(this.change)) return 'promise';\n        if (typeof this.change === 'function') return 'function';\n        return 'value';\n      }\n\n      extend(params) {\n        const callbacks = {\n          done: functionCombine(this.done, lGet(params, 'done')),\n          fail: functionCombine(this.fail, lGet(params, 'fail')),\n        };\n\n        const combinedParams = Object.assign({}, this.toJSON(), params, callbacks);\n        return new Change(combinedParams);\n      }\n\n      toJSON() {\n        const out = {};\n\n        ('tid,actions,params,method,done,id,fail,change,status,actionStatus'.split(',')).forEach((name) => {\n          out[name] = this[name];\n          if (name === 'change') return;\n          switch (out[name]) {\n            case NOOP:\n              delete out[name];\n              break;\n\n            case NOT_SET:\n              delete out[name];\n              break;\n\n            case null:\n              delete out[name];\n              break;\n\n            case undefined:\n              delete out[name];\n              break;\n\n            default:\n              // no change\n          }\n        });\n\n        return out;\n      }\n\n      asPromise(after = null) {\n        const [promise, done, fail] = explodePromise(after);\n\n        const change = this.extend({ done, fail });\n\n        const out = [change, promise];\n        return Object.assign(out, { change, promise });\n      }\n    }\n\n    propper(Change)\n      .addProp('tid', {\n        required: false,\n        type: 'integer',\n        defaultValue: null,\n      })\n      .addProp('actions', {\n        type: 'object',\n        required: false,\n        defaultValue: null,\n      })\n      .addProp('params', {\n        type: 'array',\n        required: false,\n        defaultValue: null,\n      })\n      .addProp('method', {\n        type: 'string',\n        required: 'false',\n        defaultValue: null,\n      })\n      .addProp('done', {\n        type: 'function',\n        required: false,\n        defaultValue: () => NOOP,\n      })\n      .addProp('id', {\n        required: true,\n        type: 'integer',\n      })\n      .addProp('fail', {\n        type: 'function',\n        required: false,\n        defaultValue: () => NOOP,\n      })\n      .addProp('change', {\n      })\n      .addProp('status', {\n        required: false,\n        onInvalid: 'throw',\n        tests: [[(n) => {\n          const isGood = [STORE_STATE_UNSET_VALUE,\n            NOT_SET,\n            STORE_STATUS_NEW,\n            STORE_STATUS_INITIALIZING,\n            STORE_STATUS_INITIALIZATION_ERROR,\n            STORE_STATUS_INITIALIZED].includes(n);\n          return isGood;\n        },\n        false, () => new Error('status must be an store state')]],\n      })\n      .addProp('actionStatus', {\n        required: false,\n        onInvalid: 'throw',\n        tests: [[n => [ACTION_ERROR,\n          NOT_SET,\n          ACTION_START,\n          ACTION_NOOP,\n          ACTION_COMPLETE].includes(n),\n        false, () => new Error('actionStatus must be an action state')]],\n      });\n\n    Change.nextID = 0;\n\n    return Change;\n  });\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/Change/Change.js","import change from './Change';\n\nexport default (bottle) => {\n  change(bottle);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/Change/index.js","import bottle from './bottle';\n\n\nconst {\n  Store, Engine, EngineMerger, update, mergeIntoState,\n  STORE_STATE_UNSET_VALUE\n  , STORE_STATUS_NEW\n  , STORE_STATUS_INITIALIZED\n  , STORE_STATUS_INITIALIZING\n  , STORE_STATUS_INITIALIZATION_ERROR\n  , ACTION_ERROR\n  , ACTION_START\n  , ACTION_NOOP\n  , ACTION_COMPLETE\n  , NOT_SET,\n} = bottle().container;\n\nconsole.log('Engine:', Engine);\nexport {\n  STORE_STATE_UNSET_VALUE\n  , STORE_STATUS_NEW\n  , STORE_STATUS_INITIALIZED\n  , STORE_STATUS_INITIALIZING\n  , STORE_STATUS_INITIALIZATION_ERROR\n  , ACTION_ERROR\n  , ACTION_START\n  , ACTION_NOOP\n  , ACTION_COMPLETE\n  , NOT_SET,\n  Store,\n  Engine,\n  EngineMerger,\n  update,\n  mergeIntoState,\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import Bottle from 'bottlejs';\nimport store from './Store';\nimport engine from './Engine';\nimport constants from './constants';\nimport util from './util';\nimport engineMerger from './EngineMerger';\nimport change from './Change';\n\nexport default () => {\n  const bottle = new Bottle();\n  store(bottle);\n  constants(bottle);\n  util(bottle);\n  engine(bottle);\n  engineMerger(bottle);\n  change(bottle);\n  return bottle;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/bottle.js","module.exports = require(\"bottlejs\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"bottlejs\"\n// module id = 6\n// module chunks = 0"],"sourceRoot":""}